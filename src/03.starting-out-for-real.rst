Начинаем (по настоящему)
========================

.. note::

    Erlang — относительно небольшой и простой язык (так же как C проще C++).
    В язык встроено несколько базовых типов данных, большинство из которых
    будет рассмотрено в этой главе. Так что читайте эту главу как можно
    внимательнее, так как в ней описывается всё то, на чём будут строиться
    все Erlang программы, написанные далее.

.. _numbers:

Числа
-----

В оболчке Erlang **выражения должны завершаться точкой с отступом** (перенос
строки, пробел и так далее), иначе — выражения не будут выполнены. Выражения
могут разделяться запятыми, но лишь результат последнего выражение будет
показан (но выполнены будут все). Это, конечно, необычный синтаксис для
большинства людей, который унаследован от Prolog'a.

::

    1> 2 + 15.
    17
    2> 49 * 100.
    4900
    3> 1892 - 1472.
    420
    4> 5 / 2.
    2.5
    5> 5 div 2.
    2
    6> 5 rem 2.
    1

Обратите внимание, что Erlang'у всё равно: вводите ли Вы числа с плавающей
запятой или целые числа. При выполнении арифметических операций
поддерживаются оба типа данных. Эти типы данных, пожалуй, единственные,
которые будут прозрачно обрабатываться орифметическими операторами Erlang.
Однако, для целочисленного деления Вам будет необходимо использовать функцию
``div``, а для получения остатка от деления — функцию ``rem`` (remainder).

Обратите внимание, что можно использовать несколько несколько операторов в
одном выражении. При этом математические операции подчиняются нормальным
правилам приоритета.

::

    7> (50 * 100) - 4999.
    1
    8> -(50 * 100 - 4999).
    -1
    9> -50 * (100 - 4999).
    244950

Для вывода целого числа в системе счисления с основанием, отличным от 10,
достаточно ввести число в формате ``основание#число`` (основание может быть
в диапазоне 2..36)::

    10> 2#101010.
    42
    11> 8#0677.
    447
    12> 16#AE.
    174

Потрясающе! Erlang обладает мощью калькулятора, который стоит у Вас в углу
рабочего стола, да ещё и со странным синтаксисом при этом! Абсолютно
невероятно!

.. _invariable-variables:

Неизменяемые переменные
-----------------------

С арифметикой, вроде всё в порядке. Но мы же не хотим оставаться без
возможности куда-то сохранять результаты наших вычислений. Для этой цели
мы обычно используем переменные. Если Вы читали раздел :ref:`what-is-erlang`,
то Вы уже знаете, что переменные не могут изменять своего состояния в
функциональных языках программирования. Основное поведение переменных
продемонстрировано в следующих семи выражениях (обратите внимание, что
название переменных начинается с загловной буквы)::

    1> One.
    * 1: variable 'One' is unbound
    2> One = 1.
    1
    3> Un = Uno = One = 1.
    1
    4> Two = One + One.
    2
    5> Two = 2.       
    2
    6> Two = Two + 1.
    ** exception error: no match of right hand side value 3
    7> two = 2.
    ** exception error: no match of right hand side value 2

Первое, что говорят нам эти строки, это то, что значение может быть
присвоено переменной только один раз. После этого можно долго делать вид,
что Вы присваиваете переменной значение, если переменная уже имеет
точно такое же значение. Если значения отличаются, Erlang тут же выразит
своё недовольство по этому поводу. Это правильное наблюдение, но объяснение
этому несколько сложнее и зависит от оператора ``=``. Оператор присваивания
``=`` (а не сами переменные) сравнивает значения и, если они отличаются,
сильно ругается. Если же значения равны, то он вернет значение::

    8> 47 = 45 + 2.
    47
    9> 47 = 45 + 3.
    ** exception error: no match of right hand side value 48

В случае, когда с левой стороны появляется переменная и она не связана
ни с каким значением, то Erlang автоматически связывает с этой переменной
значение из правой стороны выражения. После этого сравнение значений
справа и слева происходит успешно и переменная сохраняет новое значение
в памяти.

Такое поведение оператора ``=`` — основа так называемого *сравнения по
образцу* (pattern matching), присущего множеству функциональных языков
программирования. Его реализация в Erlang обычно расценивается, как более
полная и гибкая, нежели в альтернативных языках. Мы рассмотрим сравнение по
образцу более подробно, когда доберёмся до кортежей (tuple) и списков
(list) в этой главе, а так же в следующих главах при рассмотрении функций.

Помимо этого, строки 1—7 говорят нам, что имена переменных должны начинаться
с заглавной буквы. Выражение в строке 7 «падает» именно потому, что слово
``two`` начинается с маленькой буквы. Чисто технически, переменные могут
начинаться с символа подчёркивания (``_``), но, по соглашению, использование
таких переменных ограничено теми случаями, когда значения переменных Вам
не важны.

Так же могут быть переменные, состоящие только из символа подчёркивания::

    10> _ = 14+3.
    17
    11> _.
    * 1: variable '_' is unbound

В отличие от других типов переменных, эти не сохраняют значения. Сейчас они
кажутся бесполезными, но вы поймете их смысл, когда в этом появится
необходимость.

.. note::

    Если Вы тестируете код в оболочке и сохранили в переменной не то значение,
    то есть возможность «очистить» значение этой переменной с помощью
    функции ``f(Variable).``. Если необходимо «очистить» значения всех
    переменных, сделайте ``f().``.

.. _atoms:

Атомы
-----

Есть одна причина, почему переменные не могут начинаться с маленькой буквы,
— это атомы (atoms). Атомы — это литералы, значение которых есть их имя.
То, что видите, то и получаете. Ни больше, ни меньше. Значением атома ``cat``
будет «cat» и всё тут. И его нельзя ни переиграть, ни изменить, ни разбить
на кусочки. Это «cat». Придется иметь с ним дело.

Несмотря на то, что для создания атома достаточно одного слова с маленькой
буквы, есть несколько подходов для их создания::

    1> atom.
    atom
    2> atoms_rule.
    atoms_rule
    3> atoms_rule@erlang.
    atoms_rule@erlang
    4> 'Atoms can be cheated!'.
    'Atoms can be cheated!'
    5> atom = 'atom'.
    atom

Если атом начинается с заглавной буквы или в его составе есть неалфавитные
символы, подчеркивание (_) или @, то атом необходимо заключать в одиночные
кавычки ('). Кроме того, строка №5 в предыдушем примере демонстрирует, что
атом в кавычках равен такому же атому, записанному без кавычек.

Обычно я сравниваю атомы с константами, значением которых являются их имена.
Возможно Вы уже когда-то работали с константами. Например, предположим, что
у нас есть значения для цвета глаз: ``BLUE -> 1, BROWN -> 2, GREEN -> 3,
OTHER -> 4``. То есть, необходимо по имени константы получить соответствующее
значение. Атомы позволяют забыть про необходимость получения значения
константы: цвета глаз могут быть просто «blue», «brown», «green» и «other».
Эти цвета могут использоваться в любом участке кода: их значения никогда не
будут конфликтовать и для такой константы не бывает случаев, когда она не
определена! Если Вам действительно нужны константы со значениями, с ними
ассоциированными, то мы еще рассмотрим соответствующую возможность в главе
:doc:`./04.modules`.

Таким образом, атомы в основном полезны для объяснения или уточнения данных,
которые с ними связаны. Сам по себе атомы бесполезны. Именно поэтому мы более
не будем тратить на них время. Примеры их наилучшего использования мы увидим
когда появятся другие типы данных, связанные с атомами.

.. warning::

   Атомы учень удобны и замечательно подходят для отправки сообщения или
   для использования в качестве констант. Однако при их использовании есть
   несколько узких мест: атом регистрируется в «таблице атомов», которая
   занимает место в памяти (4 бита/атом в 32-битных системах, 8 бит/атом в
   64-битных системах). Таблица атомов не обслуживается сборщиком мусора,
   поэтому атомы будут накапливаться до тех пор, пока либо не кончится
   доступная память, либо пока не будет создано 1048577 атомов.

   Это означает, что атомы не должны создаваться динамически ни по какой
   причине. Если Ваша система должна быть надёжной и при этом у Вас
   создаются атомы при вводе данных пользователем, то у Вас серьёзные
   проблемы. Атомы следует рассматривать, прежде всего, как инструмент
   разработчика.

.. note::

   Некоторые атомы являются зарезервированными словами и не могут
   использоваться нигде кроме тех мест, где этого хотели создатели языка:
   имена функций, операторы, выражения и т.д. Таковыми являются: ``after
   and andalso band begin bnot bor bsl bsr bxor case catch cond div end
   fun if let not of or orelse query receive rem try when xor``.

.. _bool-and-compare:

Булева алгебра и операторы сравнения
------------------------------------

В беде будет тот, кто не сможет отличить мелкого от большого, правды от
истины. Как и в любом другом языке, в Erlang есть возможность использовать
логические операторы и сравнивать различные элементы.

Булева алгебра предельно проста::

    1> true and false.
    false
    2> false or true.
    true
    3> true xor false.
    true
    4> not false.
    true
    5> not (true and true).
    false

.. note::

    Логические операторы ``and`` и ``or`` всегда выполняют аргументы с обоих
    сторон от оператора. Если необходимы операторы короткой схемы выполнения
    (short-circuit) (которые выполняют правый аргумент только при неободимости),
    то следует использовать ``andalso`` и ``orelse``.

Проверка на равенство или неравенство так же предельно просто, но выглядит
немного отлично от того, что Вы могли обычно видеть в других языках::

    6> 5 =:= 5.
    true
    7> 1 =:= 0.
    false
    8> 1 =/= 0.
    true
    9> 5 =:= 5.0.
    false
    10> 5 == 5.0.
    true
    11> 5 /= 5.0.
    false

Прежде всего, если в обычном языке программирования для проверки на равенство
или неравенство используются ``==`` и ``!=``, то Erlang использует ``=:=`` и
``=/=``. Три последних выражения (строки 9-10) могут так же ввести в
заблуждение: Erlang'у всё равно, целое ли число или с плавающей точкой в
арифметических операциях, но при сравнении ему очень даже не всё равно. Но
сильно переживать не стоит по этому поводу, так как для таких случаев есть
операторы ``==`` и ``/=``. Важно всегда понимать, где необходимо проверять
точное равенство, а где допустимо приведение типов.

Другие операторы сравнения: ``<`` (меньше), ``>`` (больше), ``>=`` (больше
или равно) и ``=<`` (меньше или равно). Причем последний, как мне кажется,
перевернут и является причиной многих синтаксических ошибок в моём коде.
Так что приглядывайте за этим оператором ``=<``.

::

    12> 1 < 2.
    true
    13> 1 < 1.
    false
    14> 1 >= 1.
    true
    15> 1 =< 1.
    true

Что произойдёт, если выполнить ``5 + llama`` или ``5 == true``? Нет лучше
способа узнать это, чем выполнить и испугаться полученных сообщений об
ошибке!

::

    12> 5 + llama.
    ** exception error: bad argument in an arithmetic expression
        in operator  +/2
            called as 5 + llama

Нудык! Erlang не любит, когда неправильно используют базовые типы! В нашем
случае эмулятор вернул подробное сообщение об ошибке, в котором сообщает,
что ему очень не понравился один из аргументов, использованных вместе с
оператором ``+``!

Обычно Erlang сходит с ума, когда «видит» неправильное использование базовых
типов. Но иногда это не так::

    13> 5 =:= true.
    false

Почему же он иногда отвергает использование разных типов, а иногда — нет? И
хотя Erlang не разрешает складывать «что угодно» с «чем угодно», зато он
позволяет сравнивать их. Это потому, что создатели Erlang думали, что
прагматизм превыше теории и решили, что было бы здорово иметь возможность
достаточно просто писать такие вещи, как общие алгоритмы сортировок,
которые могли бы использовать любые термины. Так что, такое сравнение было
добавлено для того, чтобы сделать Вашу жизнь проще и Вы можете выполнять
такие сравнения в большинстве случаев.

Есть ещё одна вещь, которую надо иметь в виду при работе с булевой алгеброй
и операторами сравнения::

    14> 0 == false.
    false
    15> 1 < false.
    true

Скорее всего, Вы сейчас рвёте на себе волосы, если вы «пришли» из процедурных
или большинства объектно-ориентированных языков. Результатом строки 14
должно было быть ``true``, а строки 15 — ``false``! Кроме того, ``false``
означает 0, а ``true`` — всё остальное! Это всё так. Но не в Erlang. Ибо я
Вам наврал. Да, я это сделал. Позор мне.

В Erlang нет таких вещей, как логическое ``true`` и ``false``. Термины true
и false — атомы. Но они настолько хорошо интегрированы в язык, что у Вас не
должно быть проблем с ними. Но до тех пор, пока Вы не начнёте ожидать от них
чего-то большего, чем true и false.

.. note::

   Ниже указан приоритет элементов в операциях сравнения:
   ``число < атом < ссылка < функция < порт < pid < кортеж < список < битовая строка``
   (``number < atom < reference < fun < port < pid < tuple < list < bit string``).

   Вы пока ещё знакомы со всеми этими типами, но Вы их обязательно узнаете
   немного дальше в этом руководстве. Сейчас, просто запомните, что это — то,
   почему в Erlang можно сравнивать всё со всем! Процитирую Джо Армстронга,
   одного из создателей языка: «Фактический порядок не важен. Но важен общий
   порядок, который корректно определен».

.. _tuples:

Кортежи
-------

Кортежи — это способ организации данных. Это способ для объединения
множества терминов, когда известно их общее количество. В Erlang кортежи
имеют следующую форму: ``{Element1, Element2, ..., ElementN}``. Например,
для сообщения положения точки в декартовой системе координам мне передали
координаты (x, y). Мы можем представить эту точку в качестве кортежа из
двух терминов::

    1> X = 10, Y = 4.
    4
    2> Point = {X,Y}.
    {10,4}

В этом случае, точка будет всегда содержать два термина. То есть, вместо
двух переменных ``x``/``y``, у Вас будет одна. Однако, что делать, если
получена позиция точки и необходимо получить лишь ``x`` координату? Извлечь
такую информацию достаточно просто. Помните, чуть ранее мы узнали, что
Erlang не возражает при присваивании переменной значения, если новое и
текущее значение переменной равны. Давайте поэксплуатируем эту фичу!
Возможно Вам придется очистить значения переменных, которые мы уже
использовали ранее, с помощью функции ``f()``.

::

    3> Point = {4,5}.
    {4,5}
    4> {X,Y} = Point.
    {4,5}
    5> X.
    4
    6> {X,_} = Point.
    {4,5}

После этого значение первого элемента кортежа будет находится в переменной
``X``! Но как это произошло? Сначала ``X`` и ``Y`` не имели значения, то
есть были несвязанными (unbound) переменными. После того, как мы поместили
их в кортеж с левой стороны от оператора ``=``, оператор ``=`` сравнил
значения с обеих сторон: ``{X,Y}`` и ``{4,5}``. Erlang достаточно умён,
чтобы распаковать значения из кортежа и распределить их по несвязанным
переменным, расположенным с левой стороны. После этого выполняется лишь
сравнение: ``{4,5} = {4,5}``, которое, очевидно, является успешным! Это
есть одна из разновидностей сравнения по образцу (pattern matching).

Обратите внимание, что в строке 6 последнего примера, я использовал
анонимную переменную ``_``. Это именно то, как надо использовать такие
переменные: если значение переменной не имеет значения и не будет
использоваться. Переменные типа ``_`` всегда будут несвязанными и
работают в качестве джокера при сравнению по образцу. Для распаковки
значений кортежа сравнение по образцу будет работать только тогда, когда
количество элементов в кортежах (длина кортежа) совпадает.

::

    7> {_,_} = {4,5}.
    {4,5}
    8> {_,_} = {4,5,6}.
    ** exception error: no match of right hand side value {4,5,6}

Кортежи так же очень удобны при работе с одиночными значениями. Как так?
Простейший пример — температура::

    9> Temperature = 23.213.
    23.213

Звучит неплохо для того, чтобы сходить на пляж… Но подождите, эта
температура указана в Кельвинах, Цельсиях или Фаренгейтах?

::

    10> PreciseTemperature = {celsius, 23.213}.
    {celsius,23.213}
    11> {kelvin, T} = PreciseTemperature.
    ** exception error: no match of right hand side value {celsius,23.213}

Несмотря на появление исключительной ситуации, это именно то, что нам надо!
Это снова был пример работы сранения по образцу. Оператор ``=`` сдался,
сравнивая ``{kelvin, T}`` и ``{celsius, 23.213}``: Erlang «видит» что атомы
``celsius`` и ``kelvin`` ни разу не одинаковые, даже учитывая, что переменная
``T`` не связана. В результате чего было поднято исключение, что и прервало
исполнение кода. Благодаря такому подходу, те части нашего кода, которые
ожидают температуру в Кельвинах, не смогут обработать температуру, переданную
в Цельсиях. Такой подход позволяет программисту гораздо проще узнать, что
передётся в функции и, зачастую, работает как дополнительная отладка. Кортеж,
содержащий атом и ещё один элемент за ним, называют **тэгированный кортэж**.
Любой элемент кортежа может быть любого типа, даже ещё одним кортежем::

    12> {point, {X,Y}}.
    {point,{4,5}}

А что если, нам понадобится работать более, чем с одной точкой (Point)?

.. _lists:

Списки!
-------

Списки — это хлеб и масло многих функциональных языков. Они предназначены
для решения всех типов проблем и, несомненно, являются самым используемым
типом данных в Erlang. Списки могут состоять из чего угодно! Числа, атомы,
кортежи, вложенные списки — Ваши самые дикие мечты в одной структуре!
Базовая форма записи для списка: ``[Element1, Element2, ..., ElementN]``.
При этом, в одном списке могут быть элементы разного типа::

    1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
    [1,2,3,{numbers,[4,5,6]},5.34,atom]

Правда, просто?

::

    2> [97, 98, 99].
    "abc"

Ой—ой! Это одна из самых нелюбимых вещей в Erlang — строки! Строки — это
списки. И форма записи у них абсолютно одинаковая! Почему людям это не
нравится? Вот почему::

    3> [97,98,99,4,5,6].
    [97,98,99,4,5,6]
    4> [233].
    "é"

Erlang печатает список чисел как числа только тогда, когда есть хотя бы
один элемент списка, который нельзя представить в виде буквы! В Erlang
нет такой штуки, как настоящая строка! Этот факт ещё не раз напомнит о
себе в будущем. И Вы будете ненавидеть Erlang за это. Но не отчаивайтесь.
Есть другие способы для записи строк, с которыми познакомимся чуть позже.

.. warning::

   В Erlang нет отдельного типа данных для строк, как в большинстве
   других языков. Именно по этой причине Вы могли слышать, что Erlang —
   сильный тормоз при работе со строками. Такая ситуация сложилась в силу
   того, что Erlang создавался и использовался в телекоммуникационных
   компаниях. Они никогда (или почти никогда) не использовали строки и
   никогда не думали, что когда-либо добавят их официально. Однако, со
   временем, большинство проблем исправляется: виртуальная машина уже
   сейчас поддерживает Unicode строки, и в целом работа со строками сейчас
   быстра как никогда раньше.

   Существует ещё один способ для хранения строк — бинарные структуры
   данных. При таком подходе работа со строками становится совсем быстрой
   и легковесной. В общем, обработка строк вполне по силам для Erlang.
   Но, если Ваша задача состоит в основном из работы со строками, то лучше
   использовать такие языки, как Perl или Python.

Для склеивания списков, необходимо использовать оператор ``++``.
Противоположностью этому оператору является оператор ``--``, который
удаляет элементы из списка::

    5> [1,2,3] ++ [4,5].
    [1,2,3,4,5]
    6> [1,2,3,4,5] -- [1,2,3].
    [4,5]
    7> [2,4,2] -- [2,4].
    [2]
    8> [2,4,2] -- [2,4,2].
    []

Оба оператора — право-ассоциативные. То есть, при использовании нескольких
операторов ``--``/``++`` порядок выполнения операндов — справа на лево,
например::

    9> [1,2,3] -- [1,2] -- [3].
    [3]
    10> [1,2,3] -- [1,2] -- [2].
    [2,3]

Идём дальше. Первый элемент списка называют **головой** (**Head**), а
оставшуюся часть списка — **хвостом** (**Tail**). Мы будем использовать
две встроенные функции (built-in functions, BIF) для их получения::

    11> hd([1,2,3,4]).
    1
    12> tl([1,2,3,4]).
    [2,3,4]

.. note::

   Встроенные функции — это, обычно, те функции, которые не могут быть
   реализованы на чистом Erlang. Как правило, они реализуются на C или
   на любом другом языке, с помощью которого реализован сам Erlang (в
   80-е это был Prolog). Так же есть несколько встроенных функций, которые
   могут быть реализованы на Erlang, но всё ещё написаны на C. Сделано это
   для того, чтобы обеспечить более высокую скорость на наиболее часто
   используемых операциях. Одним из таких примеров является функция
   ``length(List)``, которая возвращает (как Вы уже, наверное, догадались)
   длину списка, переданного в качестве аргумента.

Операция доступа или добавления головы достаточно быстрая и эффективная.
Поэтому, практически по всех случаях, когда Вам придется иметь дело со
списками, Вы всегда будете работать с головой. Так как эта операция
используется настолько часто, то существует способ отделения головы от
хвоста списка с помощью сопоставления с образцом: ``[Head|Tail]``. Вот
как можно добавить новую голову в список::

    13> List = [2,3,4].
    [2,3,4]
    14> NewList = [1|List].
    [1,2,3,4]

При обработке списков часто необходимо сохранить не только голову, но и
хвост для дальнейшего использования. Если Вы вспомните, как работают
кортежи, и как мы использовали сопоставление с образцом для распаковки
значений точки (``{X,Y}``), то, наверняка, поймёте, как мы можем получить
первый элемент списка похожим образом.

::

    15> [Head|Tail] = NewList.
    [1,2,3,4]
    16> Head.
    1
    17> Tail.
    [2,3,4]
    18> [NewHead|NewTail] = Tail.
    [2,3,4]
    19> NewHead.
    2

Использованный нами оператор ``|`` называется конструктором. На самом деле,
с помощью этого оператора и значений может быть создан любой список::

    20> [1 | []].
    [1]
    21> [2 | [1 | []]].
    [2,1]
    22> [3 | [2 | [1 | []] ] ].
    [3,2,1]

Это означает, что любой список может быть построен по следующей формуле:
``[Term1| [Term2 | [... | [TermN]]]]``. То есть, список может быть определён
рекурсивно: голова предшествует хвосту, который, в свою очередь, является
головой предшествующей остальным головам. Можно провести аналогию между
списком и червяком: можно разверать червя пополам и получить двух червей.

Для людей, которые ранее никогда не использовали такие конструкторы, такой
способ построения списков в Erlang иногда сбивает с толку. Чтобы помочь Вам
поближе познакомиться с этой концепцией, ниже приведены несколько примеров
(подсказка: они все эквиваленты)::

    [a, b, c, d]
    [a, b, c, d | []]
    [a, b | [c, d]]
    [a, b | [c | [d]]]
    [a | [b | [c | [d]]]]
    [a | [b | [c | [d | [] ]]]]

После того, как придёт понимание всего этого, можно будет переходить далее
к генераторам списков.

.. note::

   Использование формы ``[1 | 2]`` даёт нам на выходе так называемый
   «неправильный список». Такие списки будут нормально работать при
   использовании ``[Head|Tail]``, но будут давать ошибку при использовании
   стандартных функций Erlang (даже ``length()``), т.к. последние ожидают
   на входе «правильные списки». Правильные списки заканчиваются пустым
   списком в последнем элементе. При объявлении элемента наподобие ``[2]``,
   список формируется автоматически правильным образом. То есть, ``[1|[2]]``
   будет работать! И хотя «неправильные списки» синтаксически правильные,
   их применение за пределами определённых пользователем структур данных
   очень ограниченно.

.. _list-comprehensions:

Генераторы списков
------------------

Генераторы списков предназначены для создания или изменения списков. Кроме
этого, генераторы позволяют создавать программы короткими и лёгкими для
понимания (по сравнению с другими способами работы со списками). Идея
генераторов основана на идеи обозначения множеств (set notation). Вам это
будет знакомо, если Вы когда-либо посещали лекции по теории множеств или
если Вы когда-либо сталкивались с математическими формулами. Обозначение
множества позволяет Вам создавать новое множество указывая те свойства,
которым должны соответствовать элементы создаваемого множества. Генераторы
списков может быть трудно понять с первого раза, но они стоят затраченных
усилий. Они позволяют создвать краткий и чистый код, так что не стесняйтесь
и попробуйте выполнить все упражнения, пока не поймёте их!

Вот пример обозначения множества :math:`\{ x \in R: x = x^2 \}`. Такая запись
означает, что результатом будет множество действительных чисел, которые равны
квадрату своего значения. Результатом будет множество: ``{0, 1}``. Вот ещё
один пример обозначения множества (по-проще): ``{x : x > 0}``. Тут мы хотим,
чтобы в множество вошли все числа для которых ``x`` > 0.

Генераторы списков в Erlang предназначены для создания списков на основе
других списков. Например, задан список: ``{2n : n in L}``, где ``L`` — это
список ``[1,2,3,4]``. Реализация в Erlang будет следующая::

    1> [2*N || N <- [1,2,3,4]].
    [2,4,6,8]

Если сравнивать математическую запись и запись, принятую в Erlang, то
найдется не так уж и много различий: фигурные скобки ``{}`` превращаются
в квадратные ``[]``, двоеточие ``:`` превращается в две трубы ``||``, а
слово ``in`` превращается в стрелку ``<-``. Изменились только символы,
а логика осталась без изменений. В предыдущем примере, каждый элемент
списка ``[1,2,3,4]`` последовательно сравнивается с образцом ``N``.
Оператор стрелки работает так же, как и оператор ``=``, за исключением
того, что он не выбрасывает исключений.

Так же в генератор можно добавить дополнительные условия. Для этого
необходимо использовать операторы, возвращающие логическое значение.
Так, например, если нам надо получить список только четных чисел из
списка от 1 до 10, то сформировать этот список можно так::

    2> [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
    [2,4,6,8,10]

Где ``X rem 2 =:= 0`` проверяет, является ли число чётным. Применение
функции к каждому элементу списка для учёта дополнительных условий —
основное практическое применение. Так, например, допустим, что у нас
есть ресторан. Входит посетитель и, видя наше меню, спрашивает, может
ли он посмотреть на цены в диапазоне $3—$10, причем итоговые цены
должны учитывать все налоги (7%)::

    3> RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
    [{steak,5.99},
    {beer,3.99},
    {poutine,3.5},
    {kitten,20.99},
    {water,0.0}]
    4> [{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >= 3, Price =< 10].
    [{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]

Тут, правда, дробная часть не особо читабельна, но суть понятна, да?
Основной шаблон использования генераторов списков в Erlang: ``NewList
= [Expression || Pattern <- List, Condition1, Condition2, ... ConditionN]``.
Фрагмент ``Pattern <- List`` называется *генерирующим выражением*. И их
может быть больше одного!

::

    5> [X+Y || X <- [1,2], Y <- [2,3]].
    [3,4,4,5]

В этом примере выполяются следующие шаги: ``1+2``, ``1+3``, ``2+2``, ``2+3``.
Если попытаться выразить шаблон использования генераторов списков более
общё, то получиться следующее: ``NewList = [Expression || GeneratorExp1,
GeneratorExp2, ..., GeneratorExpN, Condition1, Condition2, ... ConditionM]``.
Обратите внимание, что генерирующее выражение в паре со сравнением по
образцу может так же работать как фильтр::

    6> Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
    6>            {paris, sun}, {boston, fog}, {vancouver, snow}].
    [{toronto,rain},
    {montreal,storms},
    {london,fog},
    {paris,sun},
    {boston,fog},
    {vancouver,snow}]
    7> FoggyPlaces = [X || {X, fog} <- Weather].
    [london,boston]

Так, в данном примере, если элемент списка «Weather» не соответствует
шаблону ``{X, fog}``, то этот элемент просто игнорируется. Если бы
использовался оператор ``=``, то при не совпадении элемента с шаблоном
генерировалось бы исключение.

Нам осталось рассмотреть ещё один базовый тип данных. Эта поразительная
возможность позволяет интерпретировать бинарные данные с особой легкостью.

.. _bit-syntax:

Битовый синтаксис
-----------------

Большинство языков программирования позволяют работать с такими типами
данных, как числа, атомы, кортежи, списки, записи и/или структуры и т.д.
Так же большинство из них предоставляет очень низкоуровневые возможности
для работы с бинарными данными. Erlang идёт другим путём и предоставляет
весьма полезные абстракции для работы с бинарными значениями, которые
вместе со сравнением по образцу выводят работу с бинарными данными на
новый уровень. Таким образом делая работу с исходными двоичными данными
весёлой и лёгкой (нет, правда лёгкой), что требовалось для телекоммуникационных
приложений, для которых и создавались эти абстракции. Стиль и синтаксис
операций с битам довольно уникальны и сначала могут показаться немного
странными. Но если Вы знаете, как работают биты и байты, то смысл Вам
будет понятен. *В противном случае, Вы можете пропустить остальную часть
этой главы*.

Синтаксис для работы бинарными данными требует, чтобы двоичные данные
были расположены между ``<<`` и ``>>`` и разбиты на читаемые сегменты,
каждый из которых должен быть разделён запятой. Сегмент — это
последовательность битов (граница байтов не обязательно должна
соблюдаться, хотя это и поведение по-умолчанию). Допустим, необходимо
сохранить пиксель true-цвета (24 бита) оранжевого цвета. Если Вы когда-либо
смотрели на цвета в Photoshop или на закладке CSS-свойств в веб-браузере,
то Вам, наверняка, знакомо шестнадцатеричное представление цвета в виде
#RRGGBB. В этой нотации оттенок оранжевого имеет вид ``#F09A29``, который
в Erlang может быть представлен следующим образом::

    1> Color = 16#F09A29.
    15768105
    2> Pixel = <<Color:24>>.
    <<240,154,41>>

В этом примере говорится: «Поместите двоичное значение ``#F09A29`` в
24-битное пространство (8 бит для красного цвета, 8 бит — для зеленого и
8 бит — для голубого) в переменной Pixel». Позже это значение может быть
записано в файл. Если открыть этот файл в текстовом редакторе, то будет
видна лишь кучка кракозябр. Если же программно прочитать этот файл из
Erlang, то сохранённое двоичное значение будет снова преобразовано в
удобный формат: ``<<240,151,41>>``.

Но самое интересное — это возможность использование сравнения по образцу
для распаковки двочиного содержимого::

    3> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
    <<213,45,132,64,76,32,76,0,0,234,32,15>>
    4> <<Pix1,Pix2,Pix3,Pix4>> = Pixels.
    ** exception error: no match of right hand side value <<213,45,132,64,76,32,76,
    0,0,234,32,15>>
    5> <<Pix1:24, Pix2:24, Pix3:24, Pix4:24>> = Pixels.
    <<213,45,132,64,76,32,76,0,0,234,32,15>>

В строке #3 мы объявили, что будем хранить в двочином формате 4 пикселя в
RGB цвете. В 4-ой строке мы попытались распаковать 4 значения из двоичного
содержимого. Но получили исключение, так как у нас более 4-ех сегментов, а
если быть точнее, то 12 сегментов! Далее мы сообщаем Erlang'у, что каждая
переменная слева будет содержать по 24 бита данных. Для этого мы использовали
запись ``Var:24``. Далее мы можем взять первый пиксель и распаковать его
дальше в значения цветов::

    6> <<R:8, G:8, B:8>> = <<Pix1:24>>.
    <<213,45,132>>
    7> R.
    213

«Да, это здорово. А что, если я хочу получить только первый цвет от начала?
Мне надо будет распаковывать всегда все значения?» Ха! Нифига подобного! Для
таких случаев Erlang предлагает немного синтаксического сахара и сравнение
по образцу::

    8> <<R:8, Rest/binary>> = Pixels.
    <<213,45,132,64,76,32,76,0,0,234,32,15>>
    9> R.
    213

Прикольно, да? Это возможно потому, что Erlang позволяет описывать двочиный
сегмент несколькими способами:

  * Value
  * Value:Size
  * Value/TypeSpecifierList
  * Value:Size/TypeSpecifierList

где ``Size`` всегда указывает размер в битах, а ``TypeSpecifierList`` может
принимать одно из следующих значений:

.. glossary::

   Тип
    Допустимые значения: ``integer | float | binary | bytes | bitstring |
    bits | utf8 | utf16 | utf32``.

    Определяет тип используемых двоичных данных.  Обратите внимание, что
    ``bytes`` — это сокращение для ``binary``, а ``bits`` — сокращение для
    ``bitstring``. Если ничего не указано, то Erlang предполагает значение
    ``integer``.

   Наличие знака
    Допустимые значения: ``signed | unsigned``

    Имеет смысл указывать только тогда, когда тип — ``integer``. Значение
    по умолчанию — ``unsigned``.

   Порядок байтов
    Допустимые значения: ``big | little | native``

    Порядок байтов важен только тогда, когда тип: ``integer``, ``utf16``,
    ``utf32`` или ``float``. Этот параметр определяет то, как система
    считывает двоичные данные. Так, например, формат заголовка BMP-изображения
    содержит в себе размер файла в виде целого числа в 4ёх байтах. То есть,
    для файла размером 72 байта в ``little-endian`` системах размер будет
    иметь вид ``<<72,0,0,0>>``, а в ``big-endian`` — ``<<0,0,0,72>>``. Так что
    одни системы могуть прочитать это значение как «72», а другие — как
    «1207959552». Так что убедитесь, что Вы используете правильный порядок
    байтов. Значение ``native`` позволяет выбирать нужное значение «на лету»
    исходя из того, какой порядок байтов используется в CPU. Значение по
    умолчанию — ``big``.

   Размер единицы хранения (Unit)
    Пишется, как ``unit:Integer``

    Это размер сегмента в битах. Допустимый дапазон размеров: 1..256. Для целых
    значение по умолчанию — 1, для вещественных чисел, битовых строк и двочных
    данных — 8. Для типов utf8, utf16 и utf32 рамер не указывается. Значение
    Size*Unit — есть размер сегмента в битах, который должен делиться на 8 без
    остатка. Обычно размер единицы хранения используют для гарантированного
    выравнивания по байтам.

``TypeSpecifierList`` формируется из всех значений, указанных выше,
разделенных «-». Вот несколько примеров::

    10> <<X1/unsigned>> =  <<-44>>.
    <<"Ô">>
    11> X1.
    212
    12> <<X2/signed>> =  <<-44>>. 
    <<"Ô">>
    13> X2.
    -44
    14> <<X2/integer-signed-little>> =  <<-44>>.
    <<"Ô">>
    15> X2.
    -44
    16> <<N:8/unit:1>> = <<72>>.
    <<"H">>
    17> N.
    72
    18> <<N/integer>> = <<72>>.
    <<"H">>
    19> <<Y:4/little-unit:8>> = <<72,0,0,0>>.     
    <<72,0,0,0>>
    20> Y.
    72

Как видите, есть несколько способов читать, писать и интерпретировать
двоичные данные. Это может немного сбивать с толку, но это, всё равно,
гораздо проще, чем использовать типовые инструменты, предоставляемые
большинством языков программирования.

Так же в Erlang есть стандартные двоичные операции: сдвиг битов влево/вправо,
бинарные «и», «или», «исключающее или» и «не». Для этого необходимо
использовать, соответственно, следующие функции: ``bsl`` (Bit Shift Left),
``bsr`` (Bit Shift Right), ``band``, ``bor``, ``bxor`` и ``bnot``.

::

    2#00100 = 2#00010 bsl 1.
    2#00001 = 2#00010 bsr 1.
    2#10101 = 2#10001 bor 2#00101.

С помощью такой записи и битового синтаксиса, обработка и сравнение с
образцом для двоичных данных становится довольно плёвым делом. Вот пример
разбора TCP пакета::

    <<SourcePort:16, DestinationPort:16,
    AckNumber:32,
    DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
    CheckSum: 16, UrgentPointer:16,
    Payload/binary>> = SomeBinary.

Такой же подход может быть использован для любого типа бинарных данных:
декодирование видео, изображений, различных протоколов и т.п.

.. warning::

   Erlang медленный по сравнению с такими языками, как C или C++. Поэтому
   обработка видео или изображений с помощью Erlang — это, всё таки, не
   очень хорошая идея, не смотря на то, что работа с двоичными данными
   настолько проста. Erlang не силён при больших количествах сложных
   вычислений.

   Но имейте в виду, что Erlang, не смотря на это, хорошо подходит для
   задач, не требующих больших вычислений: реагирование на события, передача
   сообщений (с помощью атомов эта задача сильно упрощается) и т.д. Он может
   отлично справляться с событиями, если достаточна точность до миллисекунд,
   и поэтому, является прекрасным кандидатом для приложений полу-реального
   времени (soft-real-time).

Есть ещё один аспект работы с двоичными данными — битовые строки. Они
являются такой же надстройкой, как и обычные строки (которые реализованы
поверх списков), но более эффективны в плане расходования памяти. Обычные
строки являются связанным списком (1 нода на букву), а битовые строки больше
похожи на массивы в C. Битовые строки используют следующий синтаксис: ``<<"this
is a bit string!">>``. Единственным минусом битовых строк — это отсутствие
простоты при использовании в сравнении по образцу или других манипуляциях.
Соответственно, битовые строки используют тогда, когда текст не надо слишком
много преобразовывать или тогда, когда остро встаёт вопрос эффектичного
использования памяти.

.. note::

   Не смотря на то, что битовые строки достаточно лёгковесные, не стоит их
   использовать в качестве тэгов в кортежах. Может показаться заманчивым
   их использование в виде: ``{<<"temperature">>,50}``, но лучше всегда
   использовать этомы в этом месте. Как говорилось ранее, атомы занимают
   4 или 8 байт не зависимо от длины. Используя их, у Вас не будет лишних
   накладных расходов при копировании данных из одной функции в другую или
   при передаче данных в другую Erlang-ноду или сервер.

   Обратное так же верно: не используйте атомы вместо строк. Со строками
   можно выполнять преобразования (разбитие, регулярные выражения и т.д.),
   в то время, как с атомами можно выполнять только сравнение и ничего более.

.. _binary-comprehensions:

Бинарные генераторы
-------------------

Бинарные генераторы нужны для двоичных типов данных точно таким же образом,
как и генераторы списков нужны для списков: они предназначены делать код
компактным и выразительным. Они достаточно новые в мире Erlang. Ранее
они были в предыдущих версиях Erlang, но для корректной работы требовали
компиляции специального модуля (реализующего бинарные генераторы) с
специальным ключём. Начиная с версии R13B бинарные генераторы вошли в
базовый дистрибутив и могут использоваться где угодно, даже в оболочке::

    1> [ X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0].    
    [2,4]

Единственное, что отличает бинарные генераторы от генеторатов списков — это
то, что ``<-`` стал ``<=`` и то, что необходимо использовать ``<<>>`` вместо
``[]``. Ранее в этой главе мы рассматривали пример, где было двочиное
значение для нескольких пикселей, для которых мы использовали сравнение по
образцу для получения RGB значений для каждого пикселя. Это пример был
корректен, но при увеличении размеров структур, такой код будет трудно
понимать и поддерживать. Тот же пример может быть реализован с помощью
однострочного бинарного генератора, который гораздо проще для понимания::

    2> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
    <<213,45,132,64,76,32,76,0,0,234,32,15>>
    3> RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].
    [{213,45,132},{64,76,32},{76,0,0},{234,32,15}]

Использование ``<=`` вместо ``<-`` позволяет нам работать с бинарным потоком
как с генератором. Итоговый бинарный генератор преобразует двоичные данные
в целые числа, помещённые в кортежи. Ещё один вариант синтаксиса бинарного
генератора позволяет делает ровно обратное преобразование::

    4> << <<R:8, G:8, B:8>> ||  {R,G,B} <- RGB >>.
    <<213,45,132,64,76,32,76,0,0,234,32,15>>

Будьте осторожны, если генератор возвращает двоичное значение, то элементы
результирующего двоичного значения должны быть указаны с размерами::

    5> << <<Bin>> || Bin <- [<<3,7,5,4,7>>] >>.
    ** exception error: bad argument
    6> << <<Bin/binary>> || Bin <- [<<3,7,5,4,7>>] >>. 
    <<3,7,5,4,7>>

Можно так же объединить оба этих синтаксиса, но вариант с фиксированным
размером является более предпочтительным::

    7> << <<(X+1)/integer>> || <<X>> <= <<3,7,5,4,7>> >>.
    <<4,8,6,5,8>>

.. note::

   Во время написания этих строк бинарные генераторы использовались
   достаточно редко и были недостаточно хорошо документированы. Поэтому
   было решено сильно не погружаться в тему, а остановиться на уровне
   понимания синтаксиса и базовой функциональности. Чтобы более детально
   разобраться в битовом синтаксисе, читайте `спецификацию
   <http://user.it.uu.se/~pergu/papers/erlang05.pdf>`_.
