Модули
======

.. _what-are-modules:

Что такое модули
----------------

Работа с интерактивной оболочкой часто рассматривается как важная часть
использования динамических языков программирования. Она очень полезна
для проверки различного рода кода или программ. Большинство основных
типов данных Erlang могут быть использованы таким образом даже без
необходимости открытия текстового редактора или сохранения файлов. Если
после этих фраз Вы не станете читать дальше, то из Вас получится
хреновый Erlang-программист. Для повторного использования код необходимо
куда-то сохранять!

Вот для чего нужны модули. Модули — это пачка функций, сгруппиованная в
отдельном файле под одним именем. Кроме того, все функции в Erlang должны
быть определены только в модулях. Вы уже использовали модули, возможно,
даже не подозревая об этом. BIF'ы, упоминавшиеся в предыдущих главах,
(например, ``hd`` или ``tl``) на самом деле принадлежат модулю ``erlang``.
Так же в этом модуле определены все арифметические, логические и булевы
операторы. BIF'ы из модуля ``erlang`` отличаются от других функций: они
импортируются автоматически. Любую другую функцию, объявленную в модуле,
необходимо вызывать в формате: ``Module:Function(Arguments)``.

Вот, можете сами в этом убедиться::

    1> erlang:element(2, {a,b,c}).
    b
    2> element(2, {a,b,c}).
    b
    3> lists:seq(1,4).
    [1,2,3,4]
    4> seq(1,4).
    ** exception error: undefined shell command seq/2

В этом примере функция ``seq`` из модуля ``list`` не импортируется
автоматически, в отличии от функции ``element``. В результате чего
оболочка шлёт нам сообщение об ошибке: ``undefined shell command``,
пытаясь найти команду наподобие ``f()`` и не находящая её. Так же
в модуле ``erlang`` есть ряд функций, которые не импортируются
автоматически. Но они используются не часто.

Логично предположить, что все функции одной предметной области необходимо
размещать в одном модуле. Так, например, основные операции над списками
находятся в модуле ``lists``. А функции, отвечающие за ввод/вывод (такие,
как запись на терминал или в файл), сгруппированы в модуле ``io``. Есть,
правда, один модуль, который не соответствует этому шаблону — это
ранее упомянутый модуль ``erlang``, в котором определены функции, связанные
с математикой, преобразованиями, мультипроцессингом, настройкой виртуальной
машины и т.д. У этих функций нет ничего общего кроме того, что они являются
встроенными функциями (BIF). Так что не следует создавать модуль с именем
``erlang``. Лучше сосредоточтесь на чисто логическом разделении функций
по модулям.

.. _module-declaration:

Объявление модулей
------------------

При создании модуля можно декларировать два вида сущностей: функции и
атрибуты. Атрибуты — это метаданные, описывающие сам модуль: имя модуля,
функции, которые будут видны во внешнем мире, автор модуля и т.д. Такого
рода информация очень полезна, так как подсказывает компилятору то, как он
должен работать, а так же позволяет людям без заглядывания в исходный код
получать полезную информацию.

В настоящее время в Erlang-коде по всему миру используется большое 
количество разнообразных атрибутов. На самом деле, Вы можете объявить
даже свои собственные атрибуты. Есть несколько предопределённых атрибутов,
которые будут появляться в Вашем коде чаще, чем другие. Все атрибуты модулей
пишутся в виде: ``-имя_атрибута(Значение).``. Для того, чтобы Ваш модуль был
совместим с остальными, необходимо использовать лишь несколько из них:

.. glossary::
   -module(Name).
    Данный атрибут должен быть первым атрибутом (и выражением) в файле, так
    как это имя текущего модуля. ``Name`` — это атом (см. раздел :ref:`atoms`),
    являющийся именем, которое будет использоваться для вызова функций текущего
    модуля из других модулей. Вызовы функций выполняются в виде: ``M:F(A)``, где
    ``M`` — название модуля, ``F`` — название функции, ``A`` — аргументы,
    передаваемые в функцию.

А сейчас пришло время писать код! Наш первый модуль будет очень простым и
бесполезным. Откройте Ваш любимый текстовый редактор и наберите в нём
следующий текст, после чего сохраните его под именем ``useless.erl``::

    -module(useless).

Эта строчка кода является вполе полноценным модулем. Нет, правда! Но такой
модуль, конечно, немного бесполезен без функций. Для начала давайте решим,
какие функции будут экспортироваться из нашего модуля. Для этого нам
понадобится ещё один атрибут:

.. glossary::
   -export([Function1/Arity, Function2/Arity, ..., FunctionN/Arity]).
    Используется для определения того, какие функции текущего модуля могут
    быть вызваны извне. Атрибут принимает на вход список функций с указанием
    арности для каждой функции (``Arity``). Арность функции — это целое число,
    описывающее количество аргументов, которое может быть ей передано. Эта
    информация очень важна, так как в рамках одного модуля может быть
    объявлено несколько функций с одним и тем же именем. Но это возможно
    только тогда, когда все одноимённые функции имеют разную арность. Так,
    например, следующие функции будут различающимися: ``add(X,Y)`` и
    ``add(X,Y,Z)``, и передавать их в данный атрибут следует в виде:
    ``add/2, add/3``.

.. note::
    Экспортируемые функции представляют собой интерфейс модуля. Очень важно
    определять в этом интерфейсе только то, что необходимо для его
    использования. Такой подход позволит свободно изменять другие (скрытые)
    детали реализации модуля, не ломая код, который может зависеть от Вашего
    модуля.

Наш бесполезный модуль для начала будет экспортировать очень полезную функцию
``add``, которая будет принимать два аргумента. Ниже следующий атрибут
``-define`` необходимо добавить после объявления модуля::

    -export([add/2]).

А теперь давайте напишем функцию::

    add(A,B) ->
        A + B.

Функции пишутся в виде: ``Name(Args) -> Body``, где ``Name`` — должно быть
атомом, а ``Body`` — может бють одним или несколькими Erlang выражениями,
разделёнными запятой. Заканчиваться объявление функции должно точкой.
Обратите внимание, что в Erlang нет ключевого слова ``return``. ``Return`` —
бесполезен! Вместо этого последнее логическое выражение в функции будет
её результатом. И будет автоматически возвращаться вызываемой стороне в
виде результата.

Теперь давайте добавим ещё одну функцию (да-да, каждый учебник должен иметь
пример «Hello world»! Даже не смотря на то, что уже четверая глава!). Не
забываем добавить её в атрибут ``-export``::

    %% Выводит приветствие.
    %% io:format/1 — стандартная функция, используемая для вывода текста.
    hello() ->
        io:format("Hello, world!~n").

Что же мы видим в этой функции? Комментарии состоят из одной строки и
начинаются с символа ``%`` (иногда используют символ ``%%``, но это лишь
вопрос стиля). Так же функция ``hello/0`` показывает нам, как надо вызывать
в своих модулях функции из сторонних модулей. В нашем случае, мы вызываем
стандартную функцию ``io::format/1`` для вывода текста (как и написано в
комментариях).

И последней функцией, которую мы добавим в модуль, будет использовать обе
ранее определённые функции::

    greet_and_add_two(X) ->
        hello(),
        add(X,2).

Не забудьте добавить ``greet_and_add_two/1`` в список экспортируемых функций.
Для вызова функций ``hello/0`` и ``add/2`` нам не требуется указывать имя
модуля, так как все функции объявлены в одном и том же модуле.
