Модули
======

.. _what-are-modules:

Что такое модули
----------------

Работа с интерактивной оболочкой часто рассматривается как важная часть
использования динамических языков программирования. Она очень полезна
для проверки различного рода кода или программ. Большинство основных
типов данных Erlang могут быть использованы таким образом даже без
необходимости открытия текстового редактора или сохранения файлов. Если
после этих фраз Вы не станете читать дальше, то из Вас получится
хреновый Erlang-программист. Для повторного использования код необходимо
куда-то сохранять!

Вот для чего нужны модули. Модули — это пачка функций, сгруппиованная в
отдельном файле под одним именем. Кроме того, все функции в Erlang должны
быть определены только в модулях. Вы уже использовали модули, возможно,
даже не подозревая об этом. BIF'ы, упоминавшиеся в предыдущих главах,
(например, ``hd`` или ``tl``) на самом деле принадлежат модулю ``erlang``.
Так же в этом модуле определены все арифметические, логические и булевы
операторы. BIF'ы из модуля ``erlang`` отличаются от других функций: они
импортируются автоматически. Любую другую функцию, объявленную в модуле,
необходимо вызывать в формате: ``Module:Function(Arguments)``.

Вот, можете сами в этом убедиться::

    1> erlang:element(2, {a,b,c}).
    b
    2> element(2, {a,b,c}).
    b
    3> lists:seq(1,4).
    [1,2,3,4]
    4> seq(1,4).
    ** exception error: undefined shell command seq/2

В этом примере функция ``seq`` из модуля ``list`` не импортируется
автоматически, в отличии от функции ``element``. В результате чего
оболочка шлёт нам сообщение об ошибке: ``undefined shell command``,
пытаясь найти команду наподобие ``f()`` и не находящая её. Так же
в модуле ``erlang`` есть ряд функций, которые не импортируются
автоматически. Но они используются не часто.

Логично предположить, что все функции одной предметной области необходимо
размещать в одном модуле. Так, например, основные операции над списками
находятся в модуле ``lists``. А функции, отвечающие за ввод/вывод (такие,
как запись на терминал или в файл), сгруппированы в модуле ``io``. Есть,
правда, один модуль, который не соответствует этому шаблону — это
ранее упомянутый модуль ``erlang``, в котором определены функции, связанные
с математикой, преобразованиями, мультипроцессингом, настройкой виртуальной
машины и т.д. У этих функций нет ничего общего кроме того, что они являются
встроенными функциями (BIF). Так что не следует создавать модуль с именем
``erlang``. Лучше сосредоточтесь на чисто логическом разделении функций
по модулям.

.. _module-declaration:

Объявление модулей
------------------

При создании модуля можно декларировать два вида сущностей: функции и
атрибуты. Атрибуты — это метаданные, описывающие сам модуль: имя модуля,
функции, которые будут видны во внешнем мире, автор модуля и т.д. Такого
рода информация очень полезна, так как подсказывает компилятору то, как он
должен работать, а так же позволяет людям без заглядывания в исходный код
получать полезную информацию.

В настоящее время в Erlang-коде по всему миру используется большое
количество разнообразных атрибутов. На самом деле, Вы можете объявить
даже свои собственные атрибуты. Есть несколько предопределённых атрибутов,
которые будут появляться в Вашем коде чаще, чем другие. Все атрибуты модулей
пишутся в виде: ``-имя_атрибута(Значение).``. Для того, чтобы Ваш модуль был
совместим с остальными, необходимо использовать лишь несколько из них:

.. glossary::
   -module(Name).
    Данный атрибут должен быть первым атрибутом (и выражением) в файле, так
    как это имя текущего модуля. ``Name`` — это атом (см. раздел :ref:`atoms`),
    являющийся именем, которое будет использоваться для вызова функций текущего
    модуля из других модулей. Вызовы функций выполняются в виде: ``M:F(A)``, где
    ``M`` — название модуля, ``F`` — название функции, ``A`` — аргументы,
    передаваемые в функцию.

А сейчас пришло время писать код! Наш первый модуль будет очень простым и
бесполезным. Откройте Ваш любимый текстовый редактор и наберите в нём
следующий текст, после чего сохраните его под именем ``useless.erl``::

    -module(useless).

Эта строчка кода является вполе полноценным модулем. Нет, правда! Но такой
модуль, конечно, немного бесполезен без функций. Для начала давайте решим,
какие функции будут экспортироваться из нашего модуля. Для этого нам
понадобится ещё один атрибут:

.. glossary::
   -export([Function1/Arity, Function2/Arity, ..., FunctionN/Arity]).
    Используется для определения того, какие функции текущего модуля могут
    быть вызваны извне. Атрибут принимает на вход список функций с указанием
    арности для каждой функции (``Arity``). Арность функции — это целое число,
    описывающее количество аргументов, которое может быть ей передано. Эта
    информация очень важна, так как в рамках одного модуля может быть
    объявлено несколько функций с одним и тем же именем. Но это возможно
    только тогда, когда все одноимённые функции имеют разную арность. Так,
    например, следующие функции будут различающимися: ``add(X,Y)`` и
    ``add(X,Y,Z)``, и передавать их в данный атрибут следует в виде:
    ``add/2, add/3``.

.. note::
    Экспортируемые функции представляют собой интерфейс модуля. Очень важно
    определять в этом интерфейсе только то, что необходимо для его
    использования. Такой подход позволит свободно изменять другие (скрытые)
    детали реализации модуля, не ломая код, который может зависеть от Вашего
    модуля.

Наш бесполезный модуль для начала будет экспортировать очень полезную функцию
``add``, которая будет принимать два аргумента. Ниже следующий атрибут
``-define`` необходимо добавить после объявления модуля::

    -export([add/2]).

А теперь давайте напишем функцию::

    add(A,B) ->
        A + B.

Функции пишутся в виде: ``Name(Args) -> Body``, где ``Name`` — должно быть
атомом, а ``Body`` — может бють одним или несколькими Erlang выражениями,
разделёнными запятой. Заканчиваться объявление функции должно точкой.
Обратите внимание, что в Erlang нет ключевого слова ``return``. ``Return`` —
бесполезен! Вместо этого последнее логическое выражение в функции будет
её результатом. И будет автоматически возвращаться вызываемой стороне в
виде результата.

Теперь давайте добавим ещё одну функцию (да-да, каждый учебник должен иметь
пример «Hello world»! Даже не смотря на то, что уже четверая глава!). Не
забываем добавить её в атрибут ``-export``::

    %% Выводит приветствие.
    %% io:format/1 — стандартная функция, используемая для вывода текста.
    hello() ->
        io:format("Hello, world!~n").

Что же мы видим в этой функции? Комментарии состоят из одной строки и
начинаются с символа ``%`` (иногда используют символ ``%%``, но это лишь
вопрос стиля). Так же функция ``hello/0`` показывает нам, как надо вызывать
в своих модулях функции из сторонних модулей. В нашем случае, мы вызываем
стандартную функцию ``io::format/1`` для вывода текста (как и написано в
комментариях).

И последней функцией, которую мы добавим в модуль, будет использовать обе
ранее определённые функции::

    greet_and_add_two(X) ->
        hello(),
        add(X,2).

Не забудьте добавить ``greet_and_add_two/1`` в список экспортируемых функций.
Для вызова функций ``hello/0`` и ``add/2`` нам не требуется указывать имя
модуля, так как все функции объявлены в одном и том же модуле.

Если вдруг Вы захотите вызывать функцию ``io:format/1`` так же как и
``add/2`` или любую другую функцию, объявленную в этом же модуле, то Вам
достаточно лишь добавить следующий атрибут в начало файла:
``-import(io, [format/1]).``. После этого Вы сможете выполнять
непосредственный вызов: ``format("Hello, World!~n").``. Обобщённый формат
объявления атрибута ``-import`` следующий::

    -import(Module, [Function1/Arity, ..., FunctionN/Arity]).

Такой импорт функций является не более, чем простым сокращением. То есть
является простым удобством при написании исходного кода. Но зачастую
Erlang разработчики не рекомендуют использовать атрибут ``-import``,
так как это ухудшает читабельность кода. Так, например, если у нас есть
помимо функции ``io:format/2`` ещё и функция ``io_lib:format/2``. То, чтобы
понять, которая из них вызывается в каждом конкретном случае, необходимо
будет обратиться к началу файла модуля и найти там место, где импортируется
эта функция. Так что, сохранение название модуля при вызове функции — это
хороший подход. Обычно таким образом чаще всего импортируется лишь один из
модулей стандартной поставки — ``lists``, так как его функции обычно
используются чаще всего.

Сейчас Ваш useless_ модуль должен выглядеть следующим образом::

    -module(useless).
    -export([add/2, hello/0, greet_and_add_two/1]).

    add(A,B) ->
        A + B.

    %% Shows greetings.
    %% io:format/1 is the standard function used to output text.
    hello() ->
        io:format("Hello, world!~n").

    greet_and_add_two(X) ->
        hello(),
        add(X,2).

.. _useless: http://learnyousomeerlang.com/static/erlang/useless.erl

Мы закончили с «бесполезным» модулем. Теперь его можно сохранить под именем
``useless.erl``. Имя файла должно быть тем же, что указано в атрибуте
``-module``, после которого должно быть расширение ``.erl``, которое
является стандартным для Erlang кода.

Перед тем, как показать, как компилировать модуль и пытаться вызывать
функции из него, мы рассмотрим пример определения макроса. Макросы в Erlang
аналогичны выражению ``#define`` в C. Обычно используюся для определения
коротких функций или констант. Представляют из себя простые текстовые
выражения, которые заменяются перед компиляцией. Объявляются макросы так же,
как и атрибут модуля:: ``-define(MACRO, some_value).``. Использовать макросы
можно внутри любой функции в виде: ``?MACRO``. Так, например, макрос
обявления функции можно записать в виде: ``-define(sub(X,Y), X-Y)``. После
чего пользоваться им можно следующим образом: ``?sub(23,47)``. Позже
компилятор заменит этот код на: ``23-47``. Естественно, можно писать и
более сложные макросы, но базовый синтаксис будет таким же.

.. _compiling-the-code:

Компиляция
----------

Исходный Erlang код компилируется в байткод, чтобы потом исполняться внутри
виртуальной машины. Использовать компилятор можно из разных мест. Так,
например, его можно использовать из командной строки: ``$ erlc flags file.erl``.
А вот так его можно использовать из оболочки или из модуля:
``compile:file(FileName)``. И, наконец, только из оболочки можно использовать
функцию ``c()``.

Пришло время скомпилировать наш бесполезный модуль и попробовать использовать
его. Откройте оболочку Erlang и наберите в ней::

    1> cd("/path/to/where/you/saved/the-module/").
    "Путь к директории, где лежит модуль"
    ok

По умолчанию, оболочка ищет файлы только в текущей директории и в стандартной
библиотеке. ``cd/1`` — это функция, определённая только для оболочки Erlang,
поволяющая сменить текущую директорию, что бы было проще искать наши файлы.
Пользователям Windows необходимо всегда помнить, что в путях следует писать
прямой слеш. Итак, после того, как мы переместились в директорию, где
находится наш модуль, необходимо сделать следующее::

    2> c(useless).
    {ok,useless}
